
open System.Collections
open System.Collections.Generic
open FSharp.Compiler.SourceCodeServices
open FSharp.Compiler.Text
open FSharp.Compiler.SyntaxTree
open FSharp.Compiler.XmlDoc
open System.IO

let checker = FSharpChecker.Create()

let prelude = """
/// generated by ts2fable and transformer
module rec Hafas

open System

type Promise<'T> =
    abstract _catch: onrejected:option<obj -> 'T> -> Promise<'T>
    abstract _then: onfulfilled:option<'T -> 'TResult> * onrejected:option<obj -> 'TResult> -> Promise<'TResult>

type U2<'a, 'b> =
    | Case1 of 'a
    | Case2 of 'b

type U3<'a, 'b, 'c> =
    | Case1 of 'a
    | Case2 of 'b
    | Case3 of 'c

type U2StopLocation =
    | Stop of Stop
    | Location of Location

type U2StationStop =
    | Station of Station
    | Stop of Stop

type U3StationStopLocation =
    | Station of Station
    | Stop of Stop
    | Location of Location

"""

//
// Hafas domain specfic transformations
//

let transformTypeName str =
    if str = "ReadonlyArray" then "array"
    else if str = "ResizeArray" then "array"
    else if str = "ProductTypeMode" then "string"
    else str

let transformTypeApp str =
    if str = "U3<Station,Stop,Location>" then "U3StationStopLocation"
    else if str = "U2<Stop,Location>" then "U2StopLocation"
    else if str = "U2<Station,Stop>" then "U2StationStop"
    else if str = "U3<Station,Stop,obj>" then "U2StationStop"
    else if str = "U2<bool,obj>" then "Products"
    else str

let escapeString str =
    if str = "type" then "``" + str + "``"
    else if str = "default" then "``" + str + "``"
    else if str = "when" then "``" + str + "``"
    else if str = "public" then "``" + str + "``"
    else str

let excludeTypes = [|"ReadonlyArray"; "IExports"; "ProductTypeMode"|]

let transformTypeVals = [|"transferTime","int option";"results","int option";"bitmasks","array<int>";"``type``","string option"|]

let transformTypeDefns = [|"ScheduledDays","Map<string, bool>";"Products","Map<string, bool>";"Facilities","Map<string, string>";"Ids","Map<string, string>"|]

let transformsType (name:string) (arr: (string*string) array)=
    let index = Array.tryFindIndex (fun (s,_) -> s=name) arr
    if (index.IsSome) then
        let (_,transform) = arr.[index.Value]
        Some transform
    else None

let transformsTypeVal (name:string) =
    transformsType name transformTypeVals

let transformsTypeDefn (name:string) =
    transformsType name transformTypeDefns

//
// Parser
//

let parse fileName text =
    let checker = FSharpChecker.Create()
    let opts = 
        { FSharpParsingOptions.Default with
            SourceFiles = [|fileName|] }
    let parseFileResults = checker.ParseFile(fileName, text, opts) |> Async.RunSynchronously
    match parseFileResults.ParseTree with
    | Some tree -> tree
    | None -> failwith "Something went wrong during parsing!"

let rec visitSnyType synType = 
    match synType with
    | SynType.LongIdent(longIdentWithDots) ->
        let (LongIdentWithDots(id,_)) = longIdentWithDots
        transformTypeName id.[0].idText
    | SynType.Tuple(_,elementTypes,_) ->
        let line = List()
        for (_,elementType) in elementTypes do
            visitSnyType elementType |> line.Add
        "(" + (line |> String.concat ",") + ")"
    | SynType.Fun(argType,returnType,_) -> 
        let strargType = visitSnyType argType
        let strreturnType = visitSnyType returnType
        strargType+"->"+strreturnType 
    | SynType.Paren(innerType,_) -> visitSnyType innerType
    | SynType.App(typeName,_,typeArgs,_,_,_,_) -> 
        let strtypeName = visitSnyType typeName
        let line = List()
        for typeArg in typeArgs do
            visitSnyType typeArg |> line.Add
        if line.Count = 1 && strtypeName = "option" then line.[0] + " option"
        else if line.Count > 0 then (transformTypeApp (strtypeName + "<" + (line |> String.concat ",") + ">"))
        else strtypeName
    | _ -> failwith (sprintf " - not supported SynType: %A" synType)

let visitValSig slotSig = 
    let (SynValSig.ValSpfn(_,id,_,synType,_,_,_,xmlDoc,_,_,_)) = slotSig
    let (XmlDoc(docLines)) = xmlDoc.ToXmlDoc()
    let lines = docLines |> Array.map (fun l -> sprintf "///%s" l)
    let doc = if lines.Length > 0 then (lines |> String.concat "\n") + "\n    " else ""

    let escText = escapeString id.idText
    let strsynType =
        match transformsTypeVal escText with
        | Some transform -> transform
        | None -> visitSnyType synType
    sprintf "%s%s: %s" doc escText strsynType

let visitTypeMembers members = 
    let line = List()
    for m in members do
        match m with
        | SynMemberDefn.AbstractSlot(slotSig,_,_) -> visitValSig slotSig |> line.Add
        | _ -> failwith (sprintf " - not supported SynMemberDefn: %A" m)
    line

let visitTypeDefn typeDefn =
    let (SynTypeDefn.TypeDefn(typeInfo, typeRepr, members, range)) = typeDefn
    let (SynComponentInfo.ComponentInfo(_,__,_,id,xmlDoc,_,_,_)) = typeInfo

    let lines = List()
    let (XmlDoc(docLines)) = xmlDoc.ToXmlDoc()
    lines.AddRange (docLines |> Array.map (fun l -> sprintf "///%s" l) )
    
    let strMembers = 
        match typeRepr with
        | SynTypeDefnRepr.ObjectModel(_,members,_) -> visitTypeMembers members
        | SynTypeDefnRepr.Simple(_,_) -> List() // todo
        | _ ->failwith (sprintf " - not supported SynTypeDefnRepr: %A" typeRepr)

    let transform = transformsTypeDefn id.[0].idText
    if (transform.IsSome) then
        sprintf "type %s = %s" id.[0].idText transform.Value |> lines.Add
    else if not (Array.exists (fun s -> s=id.[0].idText) excludeTypes) then
        sprintf "type %s = {" id.[0].idText |> lines.Add
        for strMember in strMembers do
            sprintf "    %s" strMember |> lines.Add
        sprintf "}" |> lines.Add
    lines

let rec visitDeclarations decls =
    let lines = List()
    for declaration in decls do
            match declaration with
            | SynModuleDecl.Open(longDotId, range) -> ()
            | SynModuleDecl.Types(typeDefns, range) ->
                for typeDefn in typeDefns do
                    lines.AddRange (visitTypeDefn typeDefn)
            | SynModuleDecl.NestedModule(lid,__,decls0,_,_) ->
                let (SynComponentInfo.ComponentInfo(_,__,_,id,_,_,_,_)) = lid
                lines.AddRange (visitDeclarations decls0)
            | _ -> failwith (sprintf " - not supported SynModuleDecl: %A" declaration)
    lines

let visitModulesAndNamespaces modulesOrNss =
    let lines = List()
    for moduleOrNs in modulesOrNss do
        let (SynModuleOrNamespace(lid, isRec, isMod, decls, xml, attrs, _, m)) = moduleOrNs
        lines.AddRange (visitDeclarations decls)
    lines

[<EntryPoint>]
let main argv =
    match argv with 
    | [|fromFile;toFile|] -> 
        let sw = new StreamWriter(path=toFile)
        let tree = parse fromFile (SourceText.ofString ( File.ReadAllText fromFile))
        match tree with
        | ParsedInput.ImplFile(implFile) ->
            let (ParsedImplFileInput(fn, script, name, _, _, modules, _)) = implFile
            let lines = visitModulesAndNamespaces modules
            fprintfn sw "%s" prelude
            for line in lines do 
                fprintfn sw "%s" line

        | _ -> failwith "F# Interface file (*.fsi) not supported."
        printfn ""
    | _ -> failwith "two arguments expected"
    0 // return an integer exit code
