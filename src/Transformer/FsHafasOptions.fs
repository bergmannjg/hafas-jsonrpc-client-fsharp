module FsHafasOptions

//
// Hafas domain specfic transformations
//

let prelude = """/// generated by ts2fable and transformer
namespace FsHafas

#if FABLE_COMPILER
#nowarn "0059"
#endif

module rec Client =

    open System

#if FABLE_COMPILER
    open Fable.Core
    open Fable.Core.JS
#endif

#if !FABLE_COMPILER
    type Promise<'T> = Async<'T>
#endif

#if FABLE_COMPILER
    type IndexMap<'s, 'b when 's: comparison>(defaultValue: 'b) =
        [<EmitIndexer>]
        member __.Item
            with get (s: 's) = defaultValue
            and set s b = ()

        [<Emit("(Object.keys($0).filter((s) => s !== 'defaultValue'))")>]
        member __.Keys = [||] :> 's []
#else
    type IndexMap<'s, 'b when 's: comparison>(defaultValue: 'b) =
        let mutable map: Map<'s, 'b> = Map.empty

        member __.Item
            with get (s: 's) =
                match map.TryFind s with
                | Some v -> v
                | None -> defaultValue
            and set s b =
                map <- map.Add(s, b)
                ()

        member __.Keys =
            map |> Seq.map (fun kv -> kv.Key) |> Seq.toArray
#endif
"""

let postlude = """
type HafasClient =
    /// Retrieves journeys
    abstract member journeys:
        U3<string, Station, Location> ->
        U3<string, Station, Location> ->
        JourneysOptions option ->
        Promise<Journeys>
    /// refreshes a Journey
    abstract member refreshJourney: string -> RefreshJourneyOptions option -> Promise<Journey> option
    /// Refetch information about a trip
    abstract member trip: string -> string -> TripOptions option -> Promise<Trip>
    /// Retrieves departures
    abstract member departures:
        U2<string, Station> ->
        DeparturesArrivalsOptions option ->
        Promise<array<Alternative>>
    /// Retrieves arrivals
    abstract member arrivals: U2<string, Station> -> DeparturesArrivalsOptions option -> Promise<array<Alternative>>
    /// Retrieves locations or stops
    abstract member locations: string -> LocationsOptions option -> Promise<array<U3<Station,Stop,Location>>>
    /// Retrieves information about a stop
    abstract member stop: string -> StopOptions option -> Promise<U3<Station,Stop,Location>>
    /// Retrieves nearby stops from location
    abstract member nearby: Location -> NearByOptions option -> Promise<array<U3<Station,Stop,Location>>>
    /// Retrieves stations reachable within a certain time from a location
    abstract member reachableFrom: Location -> ReachableFromOptions option -> Promise<array<Duration>> option
    /// Retrieves all vehicles currently in an area.
    abstract member radar: BoundingBox -> RadarOptions option -> Promise<array<Movement>> option
    /// Retrieves trips by name.
    abstract member tripsByName: string -> TripsByNameOptions option -> Promise<array<Trip>> option
    /// Fetches all remarks known to the HAFAS endpoint
    abstract member remarks: RemarksOptions option -> Promise<array<Warning>> option
    /// Fetches all lines known to the HAFAS endpoint
    abstract member lines: string -> LinesOptions option -> Promise<array<Line>> option
    /// Fetches meta information from the HAFAS endpoint
    abstract member serverInfo: ServerOptions option -> Promise<ServerInfo>
"""

let transformType str =
    if str = "ReadonlyArray" then "array"
    else if str = "ResizeArray" then "array"
    else str

let escapeIdent str =
    if str = "type" then "``" + str + "``"
    else if str = "default" then "``" + str + "``"
    else if str = "when" then "``" + str + "``"
    else if str = "public" then "``" + str + "``"
    else if str = "to" then "``" + str + "``"
    else str

let excludeTypes = [| "ReadonlyArray"; "IExports"; "HafasClient" |]

let transformTypeVals =
    [| "transferTime", "int option"
       "transfers", "int option"
       "delay", "int option"
       "departureDelay", "int option"
       "arrivalDelay", "int option"
       "transfers", "int option"
       "transfers", "int option"
       "duration", "int option"
       "results", "int option"
       "bitmasks", "array<int>"
       "``type``", "string option" |]

let transformTypeDefns =
    [| "ScheduledDays", "IndexMap<string, bool>"
       "Products", "IndexMap<string, bool>"
       "Facilities", "IndexMap<string, string>"
       "Ids", "IndexMap<string, string>" |]

let transformsType (name: string) (arr: (string * string) array) =
    let index =
        Array.tryFindIndex (fun (s, _) -> s = name) arr

    if (index.IsSome) then
        let (_, transform) = arr.[index.Value]
        Some transform
    else
        None

let transformsTypeVal (name: string) = transformsType name transformTypeVals

let transformsTypeDefn (name: string) = transformsType name transformTypeDefns

let excludesType (name: string) =
    Array.exists (fun s -> s = name) excludeTypes

let options: Transformer.TransformerOptions =
    { prelude = Some prelude
      postlude = Some postlude
      escapeIdent = escapeIdent
      transformType = transformType
      excludesType = excludesType
      transformsTypeVal = transformsTypeVal
      transformsTypeDefn = transformsTypeDefn }
