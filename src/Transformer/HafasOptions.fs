module HafasOptions

//
// Hafas domain specfic transformations
//

let prelude = """/// generated by ts2fable and transformer
module rec Hafas

open System

type Promise<'T> =
    abstract _catch: onrejected:option<obj -> 'T> -> Promise<'T>
    abstract _then: onfulfilled:option<'T -> 'TResult> * onrejected:option<obj -> 'TResult> -> Promise<'TResult>

type U2<'a, 'b> =
    | Case1 of 'a
    | Case2 of 'b

type U3<'a, 'b, 'c> =
    | Case1 of 'a
    | Case2 of 'b
    | Case3 of 'c

type U2StopLocation =
    | Stop of Stop
    | Location of Location

type U2StationStop =
    | Station of Station
    | Stop of Stop

type U3StationStopLocation =
    | Station of Station
    | Stop of Stop
    | Location of Location

type U2HintWarning =
    | Hint of Hint
    | Warning of Warning
"""

let transformType str =
    if str = "ReadonlyArray" then "array"
    else if str = "ResizeArray" then "array"
    else if str = "U3<Station,Stop,Location>" then "U3StationStopLocation"
    else if str = "U2<Stop,Location>" then "U2StopLocation"
    else if str = "U2<Station,Stop>" then "U2StationStop"
    else if str = "U3<Station,Stop,obj>" then "U2StationStop"
    else if str = "U2<bool,obj>" then "Products"
    else if str = "U2<Hint,Warning>" then "U2HintWarning"
    else str

let escapeIdent str =
    if str = "type" then "``" + str + "``"
    else if str = "default" then "``" + str + "``"
    else if str = "when" then "``" + str + "``"
    else if str = "public" then "``" + str + "``"
    else str

let excludeTypes = [| "ReadonlyArray"; "IExports" |]

let transformTypeVals =
    [| "transferTime", "int option"
       "results", "int option"
       "bitmasks", "array<int>"
       "``type``", "string option" |]

let transformTypeDefns =
    [| "ScheduledDays", "Map<string, bool>"
       "Products", "Map<string, bool>"
       "Facilities", "Map<string, string>"
       "Ids", "Map<string, string>" |]

let transformsType (name: string) (arr: (string * string) array) =
    let index =
        Array.tryFindIndex (fun (s, _) -> s = name) arr

    if (index.IsSome) then
        let (_, transform) = arr.[index.Value]
        Some transform
    else
        None

let transformsTypeVal (name: string) = transformsType name transformTypeVals

let transformsTypeDefn (name: string) = transformsType name transformTypeDefns

let excludesType (name: string) =
    Array.exists (fun s -> s = name) excludeTypes

let options: Transformer.TransformerOptions =
    { prelude = Some prelude
      escapeIdent = escapeIdent
      transformType = transformType
      excludesType = excludesType
      transformsTypeVal = transformsTypeVal
      transformsTypeDefn = transformsTypeDefn }
